<!DOCTYPE html>
<html lang="en">

<head>
    <title>Ghost Sender</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            max-width: 600px;
            margin: auto;
        }
    </style>
</head>

<body>
    <h2>ðŸ‘» Send Assets Privately</h2>

    <label>Recipient Name (from registry):</label>
    <input type="text" id="username" value="alice" placeholder="e.g. alice">

    <label>Amount (ETH):</label>
    <input type="number" id="amount" value="0.1">

    <button onclick="sendFunds()">Generate Address & Send</button>

    <div id="logs" style="background: #f4f4f4; padding: 10px; margin-top: 20px; white-space: pre-wrap;"></div>

    <script>
        // CONFIGURATION (Replace with real deployed addresses)
        const FACTORY_ADDRESS = "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512";
        const BRIDGE_ADDRESS = "0x5FbDB2315678afecb367f032d93F642f64180aa3";
        // NOTE: You must obtain the Bytecode Hash of GhostVault manually after compilation
        // For this demo, we will rely on the Factory to verify the address, or 
        // in a real app, you fetch the init code hash from a trusted API.

        const ec = new elliptic.ec('secp256k1');
        let provider, signer;

        async function init() {
            if (window.ethereum) {
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
                log("Wallet connected: " + await signer.getAddress());
            } else {
                log("Please install MetaMask / Local Node");
            }
        }

        async function sendFunds() {
            await init();
            const username = document.getElementById("username").value;
            const amount = document.getElementById("amount").value;

            // 1. Fetch Registry
            const registry = await fetch('registry.json').then(r => r.json());
            const userKeys = registry[username];
            if (!userKeys) return log("User not found!");

            log(`Found keys for ${username}... generating Stealth Address.`);

            // 2. CRYPTO MAGIC (Dual-Key Stealth Address)

            // A. Generate Ephemeral Key (r)
            const ephemeralKey = ec.genKeyPair();
            const ephemeralPubKeyHex = ephemeralKey.getPublic(true, 'hex'); // Compressed

            // B. Calculate Shared Secret (S = r * A)
            const aliceScanKey = ec.keyFromPublic(userKeys.scanPublicKey, 'hex');
            const sharedSecretPoint = aliceScanKey.getPublic().mul(ephemeralKey.getPrivate());
            const sharedSecret = sharedSecretPoint.encode('hex');

            // C. Hash Shared Secret (Hash(S))
            const sharedHash = ethers.keccak256("0x" + sharedSecret);
            const sharedHashBN = new ethers.BN(sharedHash.slice(2), 16); // Remove '0x'

            // D. Calculate Ghost Owner (Pub = Hash(S)*G + B)
            const aliceSpendKey = ec.keyFromPublic(userKeys.spendPublicKey, 'hex');
            // Point addition: (G * sharedHash) + SpendPublic
            const offsetPoint = ec.g.mul(sharedHashBN);
            const ghostPublicPoint = offsetPoint.add(aliceSpendKey.getPublic());

            const ghostPubKeyHex = ghostPublicPoint.encode('hex');

            // Convert Public Key to Ethereum Address
            const ghostOwnerAddress = ethers.computeAddress("0x" + ghostPubKeyHex);

            // E. Generate Salt (Hash of Owner)
            const salt = ethers.keccak256(ghostOwnerAddress);

            log(`--- Stealth Data ---`);
            log(`Shared Secret (Hidden): ${sharedSecret.substring(0, 10)}...`);
            log(`Ghost Owner (Public): ${ghostOwnerAddress}`);
            log(`Salt: ${salt}`);

            // 3. Compute Counterfactual Address (On-chain check)
            const factoryAbi = ["function computeAddress(bytes32, address) view returns (address)", "function deployAndBridge(bytes32, address, address, bytes) payable"];
            const factory = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, signer);

            const computedAddress = await factory.computeAddress(salt, ghostOwnerAddress);
            log(`Target Address (Computed): ${computedAddress}`);

            // 4. THE ACTION: Send Funds + Trigger Relayer
            // In reality, User sends to 'computedAddress', and Relayer calls 'deployAndBridge'.
            // Here, we simulate the Relayer calling deployAndBridge carrying the value.

            try {
                log(`Sending ${amount} ETH and deploying forwarder...`);

                const tx = await factory.deployAndBridge(
                    salt,
                    ghostOwnerAddress,
                    ethers.ZeroAddress, // Token 0x0 = ETH
                    "0x" + ephemeralPubKeyHex, // The Clue for Alice
                    { value: ethers.parseEther(amount) }
                );

                log(`Transaction Sent! Hash: ${tx.hash}`);
                await tx.wait();
                log(`Success! Funds bridged to L2.`);
            } catch (e) {
                log(`Error: ${e.message}`);
                console.error(e);
            }
        }

        function log(msg) {
            document.getElementById("logs").innerText += msg + "\n";
        }
    </script>
</body>

</html>