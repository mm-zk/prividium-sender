<!DOCTYPE html>
<html lang="en">

<head>
    <title>Alice's Vault</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            max-width: 600px;
            margin: auto;
            background: #f0f8ff;
        }
    </style>
</head>

<body>
    <h2>ðŸ‘© Alice's Private Vault</h2>

    <div style="background: white; padding: 15px; border-radius: 8px;">
        <label>Scan Private Key (a):</label><br>
        <input type="text" id="scanPriv" value="0x1111111111111111111111111111111111111111111111111111111111111111"
            style="width:100%"><br><br>

        <label>Spend Private Key (b):</label><br>
        <input type="text" id="spendPriv" value="0x2222222222222222222222222222222222222222222222222222222222222222"
            style="width:100%">

        <br><br>
        <button onclick="scanForFunds()">Scan Blockchain for Funds</button>
    </div>

    <h3>Found Ghost Accounts:</h3>
    <div id="results"></div>

    <script>
        const FACTORY_ADDRESS = "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9";
        const ec = new elliptic.ec('secp256k1');
        let provider, signer;

        async function init() {
            if (window.ethereum) {
                provider = new ethers.BrowserProvider(window.ethereum);
                signer = await provider.getSigner();
            }
        }

        async function scanForFunds() {
            await init();
            const scanPrivKey = document.getElementById("scanPriv").value;
            const spendPrivKey = document.getElementById("spendPriv").value;
            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = "Scanning...";

            // 1. Get All 'GhostDeployed' Events
            const factoryAbi = [
                "event GhostDeployed(address indexed vault, address indexed owner, bytes ephemeralPublicKey)",
                "function computeAddress(bytes32, address) view returns (address)"
            ];
            const factory = new ethers.Contract(FACTORY_ADDRESS, factoryAbi, provider);

            // Get logs from block 0
            const filter = factory.filters.GhostDeployed();
            const events = await factory.queryFilter(filter, 0);

            resultsDiv.innerHTML = "";
            let found = 0;

            // 2. Iterate and Try to Decrypt
            for (let e of events) {
                const { vault, owner, ephemeralPublicKey } = e.args;

                try {
                    // --- RECOVERY LOGIC ---

                    // A. Recreate Shared Secret (S = a * R)
                    const scanKey = ec.keyFromPrivate(scanPrivKey.replace("0x", ""), 'hex');
                    const ephemeralKey = ec.keyFromPublic(ephemeralPublicKey.replace("0x", ""), 'hex');

                    const sharedSecretPoint = ephemeralKey.getPublic().mul(scanKey.getPrivate());
                    const sharedSecret = sharedSecretPoint.encode('hex');
                    const sharedHash = ethers.keccak256("0x" + sharedSecret);

                    // B. Calculate Expected Owner PubKey (Hash(S)*G + B)
                    const spendKey = ec.keyFromPrivate(spendPrivKey.replace("0x", ""), 'hex');
                    const sharedHashBN = new ethers.BN(sharedHash.slice(2), 16);

                    const offsetPoint = ec.g.mul(sharedHashBN);
                    const expectedOwnerPoint = offsetPoint.add(spendKey.getPublic());
                    const expectedOwnerHex = expectedOwnerPoint.encode('hex');
                    const expectedOwnerAddr = ethers.computeAddress("0x" + expectedOwnerHex);

                    // C. Match?
                    if (expectedOwnerAddr.toLowerCase() === owner.toLowerCase()) {
                        found++;

                        // D. Recover Private Key (k = Hash(S) + b)
                        const ghostPrivBN = sharedHashBN.add(spendKey.getPrivate()).umod(ec.n);
                        const ghostPrivateKey = "0x" + ghostPrivBN.toString(16, 64);

                        // Render Result
                        const el = document.createElement("div");
                        el.style = "border:1px solid green; padding:10px; margin:5px; background:#e8f5e9";
                        el.innerHTML = `
                            <strong>ðŸ’° FUNDS FOUND!</strong><br>
                            Vault: ${vault}<br>
                            Ghost Owner: ${owner}<br>
                            <em>We recovered the Private Key!</em><br>
                            <button onclick="sweepFunds('${vault}', '${ghostPrivateKey}')">Sweep to My Wallet</button>
                        `;
                        resultsDiv.appendChild(el);
                    }
                } catch (err) {
                    console.error("Math error on event", err);
                }
            }

            if (found === 0) resultsDiv.innerHTML = "No funds found belonging to you.";
        }

        window.sweepFunds = async (vaultAddr, ghostPrivKey) => {
            // Assume we are on L2 now
            // We use the Recovered Key to sign a message authorizing the sweep

            const recipient = await signer.getAddress(); // Alice's Main Wallet
            const vaultAbi = ["function sweep(address, address, bytes)"];
            const vault = new ethers.Contract(vaultAddr, vaultAbi, signer);

            alert(`Signing sweep request with recovered key:\n${ghostPrivKey.substring(0, 10)}...`);

            // 1. Sign Message with GHOST KEY (Not Metamask)
            const ghostWallet = new ethers.Wallet(ghostPrivKey);

            // Construct the exact hash Solidity expects
            const network = await provider.getNetwork();
            const chainId = network.chainId;

            // Hash(chainId, vault, token, recipient)
            const types = ["uint256", "address", "address", "address"];
            const values = [chainId, vaultAddr, ethers.ZeroAddress, recipient];
            const messageHash = ethers.solidityPackedKeccak256(types, values);
            const messageBytes = ethers.getBytes(messageHash);

            // Sign
            const signature = await ghostWallet.signMessage(messageBytes);

            // 2. Submit Transaction (Alice pays gas with main wallet)
            try {
                const tx = await vault.sweep(ethers.ZeroAddress, recipient, signature);
                alert("Sweep Transaction Sent! " + tx.hash);
                await tx.wait();
                alert("Funds arrived in main wallet!");
            } catch (e) {
                alert("Sweep failed: " + e.message);
            }
        }
    </script>
</body>

</html>